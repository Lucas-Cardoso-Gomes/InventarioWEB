@{
    ViewData["Title"] = "Acesso Remoto";
    Layout = "~/Views/Shared/_RemoteAccessLayout.cshtml";
}

<div class="text-center">
    <h1 class="display-4">Acesso Remoto a @ViewBag.Ip</h1>
    <div>
        <button id="fullscreen-btn" class="btn btn-secondary mb-2">Tela Cheia</button>
        <button id="send-ctrl-alt-del-btn" class="btn btn-danger mb-2">Enviar Ctrl+Alt+Del</button>
    </div>
    <div class="mt-3">
        <input type="file" id="file-input" class="form-control-file" />
        <button id="upload-file-btn" class="btn btn-success">Enviar Arquivo</button>
    </div>
    <div id="remote-screen-container" class="mt-3" style="position: relative; width: 100%; height: auto;">
        <video id="screen" autoplay playsinline style="width: 100%; height: auto;"></video>
    </div>
</div>

@section Scripts {
    <script src="~/lib/signalr/signalr.js"></script>
    <script>
        const ip = "@ViewBag.Ip";
        const video = document.getElementById("screen");
        const screenContainer = document.getElementById("remote-screen-container");

        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/webRtcHub")
            .build();

        let peerConnection;
        let dataChannel;
        let agentConnectionId = null;

        connection.on("AgentReady", (connectionId) => {
            agentConnectionId = connectionId;
            startSession();
        });

        async function startSession() {
            if (!agentConnectionId) {
                console.error("Agent Connection ID não está disponível.");
                return;
            }

            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            peerConnection.ontrack = event => {
                video.srcObject = event.streams[0];
            };

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    connection.invoke("SendCandidate", agentConnectionId, event.candidate);
                }
            };

            dataChannel = peerConnection.createDataChannel("remote-control");
            dataChannel.onopen = () => console.log("Canal de dados aberto!");
            dataChannel.onclose = () => console.log("Canal de dados fechado.");
            dataChannel.onmessage = (event) => {
                const msg = event.data;
                if (msg.startsWith("clipboard_data ")) {
                    const text = msg.substring("clipboard_data ".length);
                    navigator.clipboard.writeText(text);
                }
            };

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            connection.invoke("SendOffer", agentConnectionId, offer);
        }

        connection.on("ReceiveAnswer", async (from, answer) => {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        });

        connection.on("ReceiveCandidate", async (from, candidate) => {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        });

        async function init() {
            await connection.start();
            console.log("Conectado ao Hub de Sinalização.");
        }

        init();

        video.addEventListener("mousedown", e => {
            e.preventDefault();
            sendMouseEvent(`down_${e.button}`, e.clientX, e.clientY, 0);
        });

        video.addEventListener("mouseup", e => {
            e.preventDefault();
            sendMouseEvent(`up_${e.button}`, e.clientX, e.clientY, 0);
        });

        video.addEventListener("wheel", e => {
            e.preventDefault();
            sendMouseEvent("wheel", 0, 0, e.deltaY > 0 ? 120 : -120);
        }, { passive: false });

        video.addEventListener("contextmenu", e => e.preventDefault());

        function sendMouseEvent(type, x, y, deltaY) {
            if (!video.videoWidth) return;
            const rect = video.getBoundingClientRect();
            const scaleX = video.videoWidth / rect.width;
            const scaleY = video.videoHeight / rect.height;
            const scaledX = Math.round((x - rect.left) * scaleX);
            const scaledY = Math.round((y - rect.top) * scaleY);

            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(`mouse_event ${type} ${scaledX} ${scaledY} ${deltaY}`);
            }
        }

        document.addEventListener("keydown", e => handleKeyboard(e, "down"));
        document.addEventListener("keyup", e => handleKeyboard(e, "up"));

        function handleKeyboard(e, state) {
             if (document.fullscreenElement) {
                e.preventDefault();
                e.stopPropagation();
            }
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(`keyboard_event ${e.code} ${state}`);
            }
        }

        document.getElementById("fullscreen-btn").addEventListener("click", () => {
            screenContainer.requestFullscreen();
        });

         document.getElementById("send-ctrl-alt-del-btn").addEventListener("click", () => {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send('send_ctrl_alt_del');
            }
        });

        document.addEventListener("copy", (e) => {
            const text = document.getSelection().toString();
            if (text && dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(`set_clipboard ${text}`);
            }
        });

        document.addEventListener("cut", (e) => {
            const text = document.getSelection().toString();
            if (text && dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(`set_clipboard ${text}`);
            }
        });

        document.addEventListener("paste", (e) => {
             if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send('get_clipboard');
            }
        });

        const uploadButton = document.getElementById("upload-file-btn");
        const fileInput = document.getElementById("file-input");

        uploadButton.addEventListener("click", () => {
            const file = fileInput.files[0];
            if (!file) {
                return;
            }

            const chunkSize = 16384; // 16KB
            let offset = 0;

            dataChannel.send(`file_start,${file.name},${file.size}`);

            const reader = new FileReader();
            reader.onload = (e) => {
                if (e.target.error) {
                    console.error("Erro ao ler o arquivo:", e.target.error);
                    return;
                }
                dataChannel.send(e.target.result);
                offset += e.target.result.byteLength;
                if (offset < file.size) {
                    readSlice(offset);
                } else {
                    dataChannel.send("file_end");
                }
            };

            const readSlice = o => {
                const slice = file.slice(offset, o + chunkSize);
                reader.readAsArrayBuffer(slice);
            };

            readSlice(0);
        });

    </script>
}
